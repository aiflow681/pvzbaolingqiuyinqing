<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>üåå ÊòüÈôÖ‰øùÈæÑÁêÉÂ§ßÊàò - Ê§çÁâ©ÂÆàÂç´ËÄÖ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: radial-gradient(ellipse at center, #0a0e27 0%, #020308 100%);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        
        #gameContainer {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
            position: relative;
            width: 100vw;
            height: calc(100vh - 80px);
            overflow: hidden;
        }
        
        #gameContainer canvas {
            display: block;
            background: linear-gradient(180deg, #0a0e27 0%, #1a1f3a 50%, #0a0e27 100%);
            width: 100% !important;
            height: 100% !important;
            object-fit: contain;
        }
        
        @media (min-width: 768px) {
            #gameContainer {
                height: calc(100vh - 150px);
            }
        }
        
        .ui-layer {
            position: fixed;
            pointer-events: none;
            z-index: 100;
        }
        
        .score-panel {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(10,14,39,0.9) 0%, rgba(26,31,58,0.9) 100%);
            padding: 8px 20px;
            border-radius: 15px;
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px rgba(0,255,255,0.4), inset 0 0 15px rgba(0,255,255,0.1);
        }
        
        .score-title {
            font-size: 16px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            letter-spacing: 2px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .score-value {
            font-size: 24px;
            color: #ffffff;
            text-shadow: 0 0 8px #00ff88;
            text-align: center;
            font-weight: bold;
        }
        
        @media (min-width: 768px) {
            .score-panel {
                padding: 15px 40px;
                border-radius: 25px;
            }
            .score-title {
                font-size: 28px;
                margin-bottom: 10px;
            }
            .score-value {
                font-size: 36px;
            }
        }
        
        .combo-display {
            top: 70px;
            right: 10px;
            background: linear-gradient(135deg, rgba(255,102,0,0.9) 0%, rgba(255,51,102,0.9) 100%);
            padding: 5px 15px;
            border-radius: 12px;
            border: 2px solid #ffea89;
            box-shadow: 0 0 15px rgba(255,234,137,0.5);
            display: none;
        }
        
        .combo-text {
            font-size: 16px;
            color: #ffea89;
            text-shadow: 0 0 8px #ff6600;
            font-weight: bold;
        }
        
        @media (min-width: 768px) {
            .combo-display {
                top: 120px;
                right: 30px;
                padding: 10px 25px;
                border-radius: 20px;
            }
            .combo-text {
                font-size: 24px;
            }
        }
        
        .control-panel {
            bottom: 0;
            left: 0;
            width: 100%;
            height: 80px;
            display: flex;
            justify-content: space-between;
            pointer-events: all;
        }
        
        .control-btn {
            width: 30%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0,150,255,0.6) 0%, rgba(0,100,200,0.6) 100%);
            border: none;
            color: #00ffff;
            font-size: 32px;
            cursor: pointer;
            transition: all 0.2s;
            text-shadow: 0 0 10px #00ffff;
        }
        
        @media (min-width: 768px) {
            .control-panel {
                height: 150px;
            }
            .control-btn {
                width: 25%;
                font-size: 48px;
            }
        }
        
        .control-btn:active {
            background: linear-gradient(135deg, rgba(0,200,255,0.8) 0%, rgba(0,150,255,0.8) 100%);
            transform: scale(0.95);
        }
        
        .control-btn.left { border-right: 2px solid rgba(0,255,255,0.3); }
        .control-btn.right { border-left: 2px solid rgba(0,255,255,0.3); }
        
        .game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            pointer-events: all;
        }
        
        .game-over-modal.active { display: flex; }
        
        .modal-content {
            background: linear-gradient(135deg, #1a1a3e 0%, #0a0a2e 100%);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #00ffff;
            box-shadow: 0 0 50px rgba(0,255,255,0.5);
            text-align: center;
            max-width: 500px;
            width: 90%;
        }
        
        .modal-title {
            font-size: 36px;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            margin-bottom: 30px;
            letter-spacing: 2px;
        }
        
        .modal-stats {
            margin: 20px 0;
            font-size: 20px;
            color: #ffffff;
        }
        
        .modal-stat-item {
            margin: 15px 0;
            padding: 10px;
            background: rgba(0,255,255,0.1);
            border-radius: 10px;
        }
        
        .modal-stat-label {
            color: #00ffff;
            margin-right: 10px;
        }
        
        .modal-stat-value {
            color: #00ff88;
            font-weight: bold;
            font-size: 24px;
        }
        
        .modal-buttons {
            display: flex;
            gap: 20px;
            margin-top: 30px;
            justify-content: center;
        }
        
        .modal-btn {
            padding: 15px 35px;
            font-size: 18px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        
        .btn-restart {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: white;
            box-shadow: 0 5px 15px rgba(0,255,136,0.4);
        }
        
        .btn-restart:hover {
            background: linear-gradient(135deg, #00ffaa 0%, #00dd77 100%);
            box-shadow: 0 5px 20px rgba(0,255,136,0.6);
            transform: translateY(-2px);
        }
        
        .btn-refresh {
            background: linear-gradient(135deg, #00ccff 0%, #0099ff 100%);
            color: white;
            box-shadow: 0 5px 15px rgba(0,204,255,0.4);
        }
        
        .btn-refresh:hover {
            background: linear-gradient(135deg, #00ddff 0%, #00aaff 100%);
            box-shadow: 0 5px 20px rgba(0,204,255,0.6);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <div id="gameContainer"></div>
    
    <div class="ui-layer score-panel">
        <div class="score-title">üõ∏ ÊòüÈôÖ‰øùÈæÑÁêÉ üõ∏</div>
        <div class="score-value" id="scoreDisplay">0</div>
    </div>
    
    <div class="ui-layer combo-display" id="comboPanel">
        <div class="combo-text" id="comboText">COMBO x0</div>
    </div>
    
    <div class="ui-layer control-panel">
        <button class="control-btn left" id="btnLeft">‚óÄ</button>
        <button class="control-btn right" id="btnRight">‚ñ∂</button>
    </div>
    
    <div class="game-over-modal" id="gameOverModal">
        <div class="modal-content">
            <div class="modal-title">üåü Ê∏∏ÊàèÁªìÊùü üåü</div>
            <div class="modal-stats">
                <div class="modal-stat-item">
                    <span class="modal-stat-label">ÊúÄÁªàÂæóÂàÜ:</span>
                    <span class="modal-stat-value" id="finalScore">0</span>
                </div>
                <div class="modal-stat-item">
                    <span class="modal-stat-label">ÊúÄÈ´òËøûÂáª:</span>
                    <span class="modal-stat-value" id="maxCombo">0</span>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn btn-restart" id="btnRestart">ÈáçÊñ∞ÂºÄÂßã</button>
                <button class="modal-btn btn-refresh" id="btnRefresh">Âà∑Êñ∞È°µÈù¢</button>
            </div>
        </div>
    </div>

    <script type="text/javascript" src="js/phaser.min.js"></script>
    <script>
        // ========== Ê∏∏ÊàèÈÖçÁΩÆÁ≥ªÁªü ==========
        const GameConfig = {
            display: {
                aspectRatio: 1.59,
                get controlHeight() {
                    return window.innerWidth < 768 ? 80 : 150;
                },
                get baseHeight() { 
                    return window.innerHeight - this.controlHeight;
                },
                get baseWidth() { 
                    return window.innerWidth;
                },
                get scaleFactor() { 
                    return this.baseHeight / 720; 
                }
            },
            world: {
                scrollVelocity: 5,
                boundaryWidth: 30
            },
            projectile: {
                size: 0.1,
                rotationSpeed: 4,
                baseSpeed: 10
            },
            enemies: {
                collisionScale: 0.5,
                baseVelocity: 200,
                spawnIntervals: {
                    basic: { min: 1200, max: 2000 },
                    glowing: { min: 4000, max: 7000 },
                    antenna: { min: 4000, max: 7000 },
                    large: { min: 6000, max: 10000 }
                },
                scoreValues: {
                    basic: 200,
                    glowing: 300,
                    antenna: 300,
                    large: 400
                }
            },
            scoring: {
                comboThreshold: 5,
                comboMultiplier: 5,
                comboTimeWindow: 800
            },
            controls: {
                accelerationRate: 3,
                maxSpeed: 14,
                decelerationRate: 2
            }
        };

        // ========== Â∑•ÂÖ∑ÂáΩÊï∞Â∫ì ==========
        const Utils = {
            randomRange: (min, max) => min + Math.random() * (max - min),
            clamp: (value, min, max) => Math.max(min, Math.min(max, value)),
            lerp: (start, end, t) => start + (end - start) * t
        };

        // ========== ÊòæÁ§∫ÁÆ°ÁêÜÂô® ==========
        class DisplayManager {
            constructor() {
                this.setupGame();
                this.setupResizeHandler();
            }

            setupGame() {
                const config = GameConfig.display;
                const gameWidth = config.baseWidth;
                const gameHeight = config.baseHeight;
                
                this.phaserGame = new Phaser.Game(
                    gameWidth,
                    gameHeight,
                    Phaser.CANVAS,
                    'gameContainer',
                    {
                        preload: () => this.preloadAssets(),
                        create: () => this.initializeGame(),
                        update: () => this.updateGame()
                    }
                );
            }

            setupResizeHandler() {
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        const config = GameConfig.display;
                        if (this.phaserGame) {
                            this.phaserGame.scale.setGameSize(config.baseWidth, config.baseHeight);
                        }
                    }, 250);
                });
            }

            preloadAssets() {
                const game = this.phaserGame;
                const imgPath = 'img/';
                
                game.load.image('bgTexture', imgPath + 'gamebackground.jpg');
                game.load.image('projectile', imgPath + 'bowlingball.png');
                game.load.spritesheet('controlLeft', imgPath + 'btn-left.png', 192, 720);
                game.load.spritesheet('controlRight', imgPath + 'btn-right.png', 192, 720);
                game.load.spritesheet('enemyBasic', imgPath + 'zombie-normal.png', 126, 133);
                game.load.spritesheet('enemyGlowing', imgPath + 'zombie-sun.png', 130, 150);
                game.load.spritesheet('enemyAntenna', imgPath + 'zombie-flag.png', 155, 150);
                game.load.spritesheet('enemyLarge', imgPath + 'zombie-snow.png', 230, 180);
                game.load.image('boundaryLeft', imgPath + 'ditchleft.jpg');
                game.load.image('boundaryRight', imgPath + 'ditchright.jpg');
                game.load.image('overlayDark', imgPath + 'bb.jpg');
                game.load.image('btnReplay', imgPath + 'btnreplay.png');
            }

            initializeGame() {
                window.gameController = new GameController(this.phaserGame);
            }

            updateGame() {
                if (window.gameController) {
                    window.gameController.tick();
                }
            }
        }

        // ========== ËÉåÊôØÊªöÂä®Á≥ªÁªü ==========
        class ScrollingBackground {
            constructor(game) {
                this.game = game;
                this.layers = [];
                this.initialize();
            }

            initialize() {
                const scale = GameConfig.display.scaleFactor;
                const width = window.innerWidth;
                
                this.layers[0] = this.game.add.sprite(0, 0, 'bgTexture');
                this.layers[1] = this.game.add.sprite(0, -this.layers[0].height * scale, 'bgTexture');
                
                this.layers.forEach(layer => {
                    layer.width = width;
                    layer.scale.y = scale;
                    layer.tint = 0x0d1a4d;
                });
            }

            update() {
                const scale = GameConfig.display.scaleFactor;
                const speed = GameConfig.world.scrollVelocity * scale;
                const height = GameConfig.display.baseHeight;
                
                this.layers.forEach((layer, index) => {
                    layer.y += speed;
                    if (layer.y >= height) {
                        const otherLayer = this.layers[1 - index];
                        layer.y = otherLayer.y - layer.height;
                    }
                });
            }
        }

        // ========== ÊäïÂ∞ÑÁâ©Á≥ªÁªü ==========
        class Projectile {
            constructor(game) {
                this.game = game;
                this.sprite = null;
                this.create();
            }

            create() {
                const scale = GameConfig.display.scaleFactor;
                const config = GameConfig.projectile;
                
                this.sprite = this.game.add.sprite(
                    this.game.world.centerX,
                    this.game.world.height - 200 * scale,
                    'projectile'
                );
                
                this.sprite.scale.setTo(config.size * scale, config.size * scale);
                this.sprite.anchor.setTo(0.5, 0.5);
                this.game.physics.arcade.enable(this.sprite);
            }

            update() {
                this.sprite.angle += GameConfig.projectile.rotationSpeed;
            }

            reset() {
                const scale = GameConfig.display.scaleFactor;
                this.sprite.reset(
                    this.game.world.centerX,
                    this.game.world.height - 200 * scale
                );
                this.sprite.revive();
            }

            destroy() {
                this.sprite.kill();
            }

            getSprite() {
                return this.sprite;
            }
        }

        // ========== Êïå‰∫∫Âü∫Á±ª ==========
        class Enemy {
            constructor(game, type, spriteKey, width, height) {
                this.game = game;
                this.type = type;
                this.spriteKey = spriteKey;
                this.width = width;
                this.height = height;
            }

            spawn(group, xRange) {
                const scale = GameConfig.display.scaleFactor;
                const x = xRange.min + Math.random() * (xRange.max - xRange.min);
                const y = -this.height * scale;
                
                const enemy = group.create(x, y, this.spriteKey);
                enemy.scale.setTo(scale, scale);
                this.setupAnimations(enemy);
                this.setupPhysics(enemy);
                
                return enemy;
            }

            setupAnimations(sprite) {
                // Override in subclasses
            }

            setupPhysics(sprite) {
                const scale = GameConfig.display.scaleFactor;
                const collisionScale = GameConfig.enemies.collisionScale;
                
                sprite.outOfBoundsKill = true;
                sprite.body.setSize(
                    sprite.body.width * collisionScale,
                    sprite.body.height * collisionScale,
                    this.getOffsetX() * scale,
                    0
                );
                sprite.body.velocity.y = GameConfig.enemies.baseVelocity * scale;
            }

            getOffsetX() {
                return 0;
            }
        }

        // ========== ÂÖ∑‰ΩìÊïå‰∫∫Á±ªÂûã ==========
        class BasicEnemy extends Enemy {
            constructor(game) {
                super(game, 'basic', 'enemyBasic', 126, 133);
            }

            setupAnimations(sprite) {
                sprite.animations.add('alive', [0,1,2,3,2,1], 5, true);
                sprite.animations.add('dead', [7,8,9,10,11,12,13], 15, true);
                sprite.animations.play('alive');
            }

            getOffsetX() {
                return 38;
            }
        }

        class GlowingEnemy extends Enemy {
            constructor(game) {
                super(game, 'glowing', 'enemyGlowing', 130, 150);
            }

            setupAnimations(sprite) {
                sprite.animations.add('alive', [0,1,2,3,4,5,6,7,8,9,8,7,6,5,4,3,2,1], 5, true);
                sprite.animations.add('dead', [10,11,12,13,14,15,16,17], 15, true);
                sprite.animations.play('alive');
            }

            getOffsetX() {
                return 39;
            }
        }

        class AntennaEnemy extends Enemy {
            constructor(game) {
                super(game, 'antenna', 'enemyAntenna', 155, 150);
            }

            setupAnimations(sprite) {
                sprite.animations.add('alive', [0,1,2,3,4,3,2,1], 5, true);
                sprite.animations.add('dead', [5,6,7,8,9,10,11,12,13], 15, true);
                sprite.animations.play('alive');
            }

            getOffsetX() {
                return 55.5;
            }
        }

        class LargeEnemy extends Enemy {
            constructor(game) {
                super(game, 'large', 'enemyLarge', 230, 180);
            }

            setupAnimations(sprite) {
                sprite.animations.add('alive', [0,1,2,3,4,5,4,3,2,1], 5, true);
                sprite.animations.add('dead', [6,7,8,9,10,11,12], 15, true);
                sprite.animations.play('alive');
            }

            getOffsetX() {
                return 0;
            }
        }

        // ========== Êïå‰∫∫ÁÆ°ÁêÜÂô® ==========
        class EnemyManager {
            constructor(game) {
                this.game = game;
                this.groups = {};
                this.spawners = {};
                this.enemyTypes = {};
                this.initialize();
            }

            initialize() {
                this.enemyTypes = {
                    basic: new BasicEnemy(this.game),
                    glowing: new GlowingEnemy(this.game),
                    antenna: new AntennaEnemy(this.game),
                    large: new LargeEnemy(this.game)
                };

                Object.keys(this.enemyTypes).forEach(type => {
                    this.groups[type] = this.game.add.group();
                    this.groups[type].enableBody = true;
                });

                this.startSpawning();
            }

            startSpawning() {
                const scale = GameConfig.display.scaleFactor;
                const worldWidth = this.game.world.width;
                
                const intervals = GameConfig.enemies.spawnIntervals;
                
                this.spawners.basic = this.game.time.events.loop(
                    Utils.randomRange(intervals.basic.min, intervals.basic.max),
                    () => this.spawnEnemy('basic', { min: 30 * scale, max: worldWidth - 156 * scale })
                );
                
                this.spawners.glowing = this.game.time.events.loop(
                    Utils.randomRange(intervals.glowing.min, intervals.glowing.max),
                    () => this.spawnEnemy('glowing', { min: 30 * scale, max: worldWidth - 160 * scale })
                );
                
                this.spawners.antenna = this.game.time.events.loop(
                    Utils.randomRange(intervals.antenna.min, intervals.antenna.max),
                    () => this.spawnEnemy('antenna', { min: 30 * scale, max: worldWidth - 185 * scale })
                );
                
                this.spawners.large = this.game.time.events.loop(
                    Utils.randomRange(intervals.large.min, intervals.large.max),
                    () => this.spawnEnemy('large', { min: 5 * scale, max: worldWidth - 230 * scale })
                );
            }

            spawnEnemy(type, xRange) {
                this.enemyTypes[type].spawn(this.groups[type], xRange);
            }

            getGroup(type) {
                return this.groups[type];
            }

            destroyAll() {
                Object.values(this.groups).forEach(group => {
                    group.destroy(true, true);
                });
            }
        }

        // ========== ËÆ°ÂàÜÁ≥ªÁªü ==========
        class ScoringSystem {
            constructor() {
                this.currentScore = 0;
                this.comboCount = 0;
                this.maxCombo = 0;
                this.lastHitTime = 0;
                this.uiElements = {
                    score: document.getElementById('scoreDisplay'),
                    combo: document.getElementById('comboPanel'),
                    comboText: document.getElementById('comboText')
                };
            }

            addPoints(enemyType) {
                const points = GameConfig.enemies.scoreValues[enemyType];
                this.currentScore += points;
                this.updateCombo();
                this.updateDisplay();
            }

            updateCombo() {
                const now = Date.now();
                const config = GameConfig.scoring;
                
                if (this.comboCount === 0) {
                    this.lastHitTime = now;
                    this.comboCount = 1;
                } else if (now - this.lastHitTime <= config.comboTimeWindow) {
                    this.comboCount++;
                    this.lastHitTime = now;
                    
                    if (this.comboCount > config.comboThreshold) {
                        const bonus = config.comboMultiplier * this.comboCount;
                        this.currentScore += bonus;
                    }
                } else {
                    if (this.maxCombo < this.comboCount) {
                        this.maxCombo = this.comboCount;
                    }
                    this.comboCount = 1;
                    this.lastHitTime = now;
                }
                
                this.updateComboDisplay();
            }

            updateDisplay() {
                this.uiElements.score.textContent = this.currentScore;
            }

            updateComboDisplay() {
                if (this.comboCount > 1) {
                    this.uiElements.combo.style.display = 'block';
                    this.uiElements.comboText.textContent = `COMBO x${this.comboCount}`;
                } else {
                    this.uiElements.combo.style.display = 'none';
                }
            }

            reset() {
                if (this.maxCombo < this.comboCount) {
                    this.maxCombo = this.comboCount;
                }
                this.currentScore = 0;
                this.comboCount = 0;
                this.lastHitTime = 0;
                this.updateDisplay();
                this.updateComboDisplay();
            }

            getScore() {
                return this.currentScore;
            }

            getMaxCombo() {
                if (this.maxCombo < this.comboCount) {
                    return this.comboCount;
                }
                return this.maxCombo;
            }
        }

        // ========== Á¢∞ÊíûÂ§ÑÁêÜÂô® ==========
        class CollisionHandler {
            constructor(game, projectile, enemyManager, scoringSystem) {
                this.game = game;
                this.projectile = projectile;
                this.enemyManager = enemyManager;
                this.scoringSystem = scoringSystem;
            }

            handleEnemyCollision(projectileSprite, enemySprite, enemyType) {
                const scale = GameConfig.display.scaleFactor;
                
                enemySprite.animations.play('dead', null, false, true);
                
                const projectileX = projectileSprite.x;
                const enemyCenter = enemySprite.x + enemySprite.body.width / 2;
                const impactForce = enemyType === 'large' ? scale / 30 : scale / 90;
                
                if (projectileX <= enemyCenter) {
                    projectileSprite.body.velocity.x -= (enemyCenter - projectileX) * impactForce;
                    enemySprite.angle -= 0.5;
                    if (enemySprite.angle === -2) {
                        this.scoringSystem.addPoints(enemyType);
                    }
                } else {
                    projectileSprite.body.velocity.x += (projectileX - enemyCenter) * impactForce;
                    enemySprite.angle += 0.5;
                    if (enemySprite.angle === 2) {
                        this.scoringSystem.addPoints(enemyType);
                    }
                }
            }

            checkCollisions() {
                const projectileSprite = this.projectile.getSprite();
                
                Object.entries(this.enemyManager.groups).forEach(([type, group]) => {
                    this.game.physics.arcade.overlap(
                        projectileSprite,
                        group,
                        (proj, enemy) => this.handleEnemyCollision(proj, enemy, type),
                        null,
                        this
                    );
                });
            }
        }

        // ========== ËæìÂÖ•ÊéßÂà∂Âô® ==========
        class InputController {
            constructor(projectile) {
                this.projectile = projectile;
                this.leftVelocity = 4;
                this.rightVelocity = 4;
                this.accelerationBoost = 0;
                this.setupControls();
            }

            setupControls() {
                const btnLeft = document.getElementById('btnLeft');
                const btnRight = document.getElementById('btnRight');
                
                btnLeft.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.moveLeft();
                });
                
                btnRight.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.moveRight();
                });
                
                btnLeft.addEventListener('click', () => this.moveLeft());
                btnRight.addEventListener('click', () => this.moveRight());
                
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowLeft') this.moveLeft();
                    if (e.key === 'ArrowRight') this.moveRight();
                });
            }

            moveLeft() {
                const config = GameConfig.controls;
                const scale = GameConfig.display.scaleFactor;
                const baseSpeed = GameConfig.projectile.baseSpeed;
                
                if (this.leftVelocity < config.maxSpeed) {
                    this.leftVelocity += config.accelerationRate;
                }
                if (this.leftVelocity > config.maxSpeed) {
                    this.leftVelocity = config.maxSpeed;
                }
                if (this.rightVelocity > 0) {
                    this.rightVelocity -= config.decelerationRate;
                }
                
                const velocity = baseSpeed * this.leftVelocity * scale;
                this.projectile.getSprite().body.velocity.x -= velocity + this.accelerationBoost;
            }

            moveRight() {
                const config = GameConfig.controls;
                const scale = GameConfig.display.scaleFactor;
                const baseSpeed = GameConfig.projectile.baseSpeed;
                
                if (this.rightVelocity < config.maxSpeed) {
                    this.rightVelocity += config.accelerationRate;
                }
                if (this.rightVelocity > config.maxSpeed) {
                    this.rightVelocity = config.maxSpeed;
                }
                if (this.leftVelocity > 0) {
                    this.leftVelocity -= config.decelerationRate;
                }
                
                const velocity = baseSpeed * this.rightVelocity * scale;
                this.projectile.getSprite().body.velocity.x += velocity + this.accelerationBoost;
            }

            updateAcceleration(value) {
                this.accelerationBoost = value;
            }

            reset() {
                this.leftVelocity = 4;
                this.rightVelocity = 4;
                this.accelerationBoost = 0;
            }
        }

        // ========== ËæπÁïåÁ≥ªÁªü ==========
        class BoundarySystem {
            constructor(game) {
                this.game = game;
                this.boundaries = {};
                this.initialize();
            }

            initialize() {
                const scale = GameConfig.display.scaleFactor;
                
                this.boundaries.left = this.game.add.sprite(0, 0, 'boundaryLeft');
                this.boundaries.left.scale.setTo(scale, scale);
                this.game.physics.arcade.enable(this.boundaries.left);
                
                this.boundaries.right = this.game.add.sprite(this.game.world.width, 0, 'boundaryRight');
                this.boundaries.right.scale.setTo(scale, scale);
                this.boundaries.right.anchor.setTo(1, 0);
                this.game.physics.arcade.enable(this.boundaries.right);
            }

            checkCollision(projectile, onCollision) {
                Object.values(this.boundaries).forEach(boundary => {
                    this.game.physics.arcade.overlap(
                        projectile.getSprite(),
                        boundary,
                        onCollision,
                        null,
                        this
                    );
                });
            }
        }

        // ========== Ê∏∏ÊàèÁä∂ÊÄÅÁÆ°ÁêÜÂô® ==========
        class GameStateManager {
            constructor() {
                this.isGameOver = false;
                this.isPaused = false;
                this.accelerationTimer = 0;
                this.accelerationValue = 0;
                this.frameCount = 0;
                this.collisionEnabled = false;
            }

            triggerGameOver() {
                this.isGameOver = true;
            }

            reset() {
                this.isGameOver = false;
                this.isPaused = false;
                this.accelerationTimer = 0;
                this.accelerationValue = 0;
                this.frameCount = 0;
                this.collisionEnabled = false;
            }

            updateAcceleration() {
                this.accelerationTimer++;
                if (this.accelerationTimer > 10) {
                    this.accelerationValue++;
                    this.accelerationTimer = 0;
                }
            }

            updateFrame() {
                this.frameCount++;
                if (this.frameCount > 10) {
                    this.collisionEnabled = true;
                }
            }

            canCheckCollision() {
                return this.collisionEnabled;
            }

            getAcceleration() {
                return this.accelerationValue;
            }
        }

        // ========== Ê∏∏ÊàèÁªìÊùüÁïåÈù¢ ==========
        class GameOverUI {
            constructor() {
                this.modal = document.getElementById('gameOverModal');
                this.finalScoreEl = document.getElementById('finalScore');
                this.maxComboEl = document.getElementById('maxCombo');
                this.setupButtons();
            }

            setupButtons() {
                document.getElementById('btnRestart').addEventListener('click', () => {
                    this.hide();
                    if (window.gameController) {
                        window.gameController.restart();
                    }
                });
                
                document.getElementById('btnRefresh').addEventListener('click', () => {
                    location.reload();
                });
            }

            show(score, maxCombo) {
                this.finalScoreEl.textContent = score;
                this.maxComboEl.textContent = maxCombo;
                this.modal.classList.add('active');
            }

            hide() {
                this.modal.classList.remove('active');
            }
        }

        // ========== ‰∏ªÊ∏∏ÊàèÊéßÂà∂Âô® ==========
        class GameController {
            constructor(game) {
                this.game = game;
                this.game.physics.startSystem(Phaser.Physics.ARCADE);
                
                this.background = new ScrollingBackground(game);
                this.projectile = new Projectile(game);
                this.enemyManager = new EnemyManager(game);
                this.scoringSystem = new ScoringSystem();
                this.boundarySystem = new BoundarySystem(game);
                this.inputController = new InputController(this.projectile);
                this.collisionHandler = new CollisionHandler(
                    game,
                    this.projectile,
                    this.enemyManager,
                    this.scoringSystem
                );
                this.stateManager = new GameStateManager();
                this.gameOverUI = new GameOverUI();
            }

            tick() {
                if (this.stateManager.isGameOver) return;
                
                this.background.update();
                this.projectile.update();
                this.collisionHandler.checkCollisions();
                
                // Update frame counter and check if collision detection should be enabled
                this.stateManager.updateFrame();
                
                // Only check boundary collision after initial frames
                if (this.stateManager.canCheckCollision()) {
                    this.boundarySystem.checkCollision(
                        this.projectile,
                        () => this.handleGameOver()
                    );
                }
                
                this.stateManager.updateAcceleration();
                this.inputController.updateAcceleration(
                    this.stateManager.getAcceleration()
                );
            }

            handleGameOver() {
                this.stateManager.triggerGameOver();
                this.projectile.destroy();
                
                const finalScore = this.scoringSystem.getScore();
                const maxCombo = this.scoringSystem.getMaxCombo();
                
                this.gameOverUI.show(finalScore, maxCombo);
                this.game.time.events.pause();
            }

            restart() {
                this.scoringSystem.reset();
                this.stateManager.reset();
                this.inputController.reset();
                
                this.enemyManager.destroyAll();
                this.enemyManager = new EnemyManager(this.game);
                
                this.projectile.reset();
                
                this.collisionHandler = new CollisionHandler(
                    this.game,
                    this.projectile,
                    this.enemyManager,
                    this.scoringSystem
                );
                
                this.game.time.events.resume();
            }
        }

        // ========== ÂàùÂßãÂåñÊ∏∏Êàè ==========
        window.addEventListener('DOMContentLoaded', () => {
            new DisplayManager();
        });
    </script>
</body>
</html>


    <script>
        // Handle window resize for responsive gameplay
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Reload to adjust canvas size
                location.reload();
            }, 500);
        });
        
        // Ensure keyboard focus after page load
        window.addEventListener('load', () => {
            document.body.focus();
            document.body.click();
        });
        
        // Re-focus on any click to ensure keyboard works
        document.addEventListener('click', () => {
            document.body.focus();
        });
    </script>
